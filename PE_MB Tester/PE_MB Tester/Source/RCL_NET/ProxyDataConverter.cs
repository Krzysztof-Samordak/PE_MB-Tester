/******************************************************
 *       Copyright Keysight Technologies 2018-2021
 ******************************************************/
using System;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;

namespace Keysight.ApiCoreLibraries
{
    /// <summary>
    /// ProxyDataConverter is a helper class for converting data from a proxy object to .NET object
    /// if a type uses host-proxy marshaling, a proxy class is generated by Rooftop, usually it is a class in the bridge namespace
    /// with the same name as the .NET class and has methods/properties with same name. But the implementation are different.
    /// This class provides a generic method to get a .NET object from a proxy object.
    /// by 02-13-2017, this class is only used in custom event args.
    /// </summary>
    internal class ProxyDataConverter
    {
        #region classes representing a setter for a property
        /// <summary>
        /// 
        /// </summary>
        interface ISettableMember
        {
            void SetValue(object obj, object value);
        }
        /// <summary>
        /// 
        /// </summary>
        class PropertySetter: ISettableMember
        {
            private PropertyInfo _member = null;

            public PropertySetter(PropertyInfo propInfo)
            {
                _member = propInfo;
            }

            public void SetValue(object obj, object value)
            {
                _member.SetValue(obj, value, null);
            }
        }
        /// <summary>
        /// 
        /// </summary>
        class FieldSetter : ISettableMember
        {
            private FieldInfo _member = null;

            public FieldSetter(FieldInfo fieldInfo)
            {
                _member = fieldInfo;
            }

            public void SetValue(object obj, object value)
            {
                _member.SetValue(obj, value);
            }
        }
        #endregion

        // Dictionary to cache the setters for the properties.
        private Dictionary<Type, Dictionary<PropertyInfo, ISettableMember>> _setters = 
            new Dictionary<Type, Dictionary<PropertyInfo, ISettableMember>>();

        /// <summary>
        /// Get the setters for a type
        /// </summary>
        /// <param name="t"></param>
        /// <param name="proxyObj">An object of the proxy class, this is used to find setters at the first time</param>
        /// <returns>Dictionary<PropertyInfo, ISettableMember></returns>
        private Dictionary<PropertyInfo, ISettableMember> GetSetters(Type t, Object proxyObj)
        {
            if( _setters.ContainsKey(t))
            {
                return _setters[t];
            }

            var setter = new Dictionary<PropertyInfo, ISettableMember>();

            foreach (var prop in t.GetProperties(BindingFlags.Public | BindingFlags.Instance))
            {
                if (prop.CanWrite)
                {
                    setter[prop] = new PropertySetter(prop);
                }
                else
                {
                    var field = GetPropertyField(t, prop, proxyObj);
                    if (field != null)
                    {
                        setter[prop] = new FieldSetter(field);
                    }                    
                }
            }
            _setters[t] = setter;
            return setter;
        }

        /// <summary>
        /// Get backing field for auto property
        /// </summary>
        /// <param name="objT"></param>
        /// <param name="propertyName"></param>
        /// <returns></returns>
        private FieldInfo GetBackingField(Type objT, String propertyName)
        {
            var fieldName = string.Format("<{0}>k__BackingField", propertyName);
            return objT.GetField(fieldName, BindingFlags.Instance | BindingFlags.NonPublic);
        }
        /// <summary>
        /// Compute the similarity of two strings
        /// </summary>
        /// <param name="s"></param>
        /// <param name="t"></param>
        /// <returns>differences</returns>
        private int ComputeStringSimilarity(string s, string t)
        {
            if (string.IsNullOrEmpty(s))
            {
                if (string.IsNullOrEmpty(t))
                    return 0;
                return t.Length;
            }

            if (string.IsNullOrEmpty(t))
            {
                return s.Length;
            }

            int n = s.Length;
            int m = t.Length;
            int[,] d = new int[n + 1, m + 1];

            // initialize the top and right of the table to 0, 1, 2, ...
            for (int i = 0; i <= n; d[i, 0] = i++) ;
            for (int j = 1; j <= m; d[0, j] = j++) ;

            for (int i = 1; i <= n; i++)
            {
                for (int j = 1; j <= m; j++)
                {
                    int cost = (t[j - 1] == s[i - 1]) ? 0 : 1;
                    int min1 = d[i - 1, j] + 1;
                    int min2 = d[i, j - 1] + 1;
                    int min3 = d[i - 1, j - 1] + cost;
                    d[i, j] = Math.Min(Math.Min(min1, min2), min3);
                }
            }
            return d[n, m];
        }
        /// <summary>
        /// Get the value for a property from proxy object
        /// </summary>
        /// <param name="prop"></param>
        /// <param name="proxyObj"></param>
        /// <returns></returns>
        private Object GetPropertyValueFromProxyObj(PropertyInfo prop, Object proxyObj)
        {
            Type inputType = proxyObj.GetType();
            object theValue = null;
            Type matchedType = null;

            PropertyInfo searchProp = inputType.GetProperty(prop.Name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.GetProperty);
            if (searchProp != null)
            {
                matchedType = searchProp.PropertyType;
                theValue = searchProp.GetValue(proxyObj, null);
            }
            else
            {
                MethodInfo searchMethod = inputType.GetMethod("Get" + prop.Name, BindingFlags.Public | BindingFlags.Instance);
                if (searchMethod != null)
                {
                    matchedType = searchMethod.ReturnType;
                    theValue = searchMethod.Invoke(proxyObj, new object[] { });
                }
            }

            if(theValue.GetType() != prop.PropertyType)
            {
                var ctor = prop.PropertyType.GetConstructor(new[] { theValue.GetType() });
                if(ctor != null)
                {
                    theValue = ctor.Invoke(new Object[] { theValue });
                }
            }

            if (prop.PropertyType.FullName != matchedType.FullName && prop.PropertyType.Name == matchedType.Name)
            {
                if (prop.PropertyType.IsEnum && matchedType.IsEnum)
                {
                    var theStringValue = theValue.ToString();
                    theValue = Enum.Parse(prop.PropertyType, theStringValue);
                }
                else
                {
                    theValue = ConvertEquivalent(prop.PropertyType, theValue);
                }
            }

            return theValue;
        }

        /// <summary>
        /// Get the equivalent field for a property
        /// </summary>
        /// <param name="t"></param>
        /// <param name="p"></param>
        /// <param name="proxyObj"></param>
        /// <returns></returns>
        private FieldInfo GetPropertyField(Type t, PropertyInfo p, object proxyObj)
        {
            // Check if can get it as a auto property
            var field = GetBackingField(t, p.Name);
            if (field != null)
                return field;

            var allFields = t.GetFields(BindingFlags.Instance | BindingFlags.NonPublic);
            if (allFields == null)
                return null;

            var sameTypeFields = new List<KeyValuePair<FieldInfo, int>>();
            foreach(var f in allFields)
            {
                if(f.FieldType == p.PropertyType)
                {
                    var similarity = ComputeStringSimilarity(f.Name, p.Name);
                    sameTypeFields.Add(new KeyValuePair<FieldInfo, int>(f, similarity));
                }
            }

            if (sameTypeFields.Count == 0)
                return null;

            if (sameTypeFields.Count == 1)
                return sameTypeFields[0].Key;

            sameTypeFields.Sort((pair1, pair2) => pair1.Value.CompareTo(pair2.Value));
            foreach(var keyValue in sameTypeFields)
            {
                //verify the setter
                Object objectT = FormatterServices.GetUninitializedObject(t);
                var theValue = GetPropertyValueFromProxyObj(p, proxyObj);
                if(theValue == null)
                {
                    throw new ApplicationException(string.Format("There is no equivalent property/method for {0}.{1} in {2}", 
                        t.Name, p.Name, proxyObj.GetType().Name));
                }
                keyValue.Key.SetValue(objectT, theValue);
                if(theValue == p.GetValue(objectT, null))
                {
                    return keyValue.Key;                    
                }
            }

            return null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="t"></param>
        /// <param name="proxyObj"></param>
        /// <returns></returns>
        public Object ConvertEquivalent(Type t, Object proxyObj)
        {
            if (t == null || proxyObj == null)
            {
                throw new ArgumentNullException("proxyObj parameter should not be null in ConvertEquivalent");
            }

            /// it is unnecessary for the type name to be same
            //if (proxyObj.GetType().Name != t.Name)
            //{
            //    throw new ArgumentException("The type of proxyObj is not equivalent type with t");
            //}

            Object objectT = FormatterServices.GetUninitializedObject(t);

            var setters = GetSetters(t, proxyObj);
            foreach (var prop in t.GetProperties(BindingFlags.Public | BindingFlags.Instance))
            {
                var theValue = GetPropertyValueFromProxyObj(prop, proxyObj); 
                ISettableMember setter;
                if (setters.TryGetValue(prop, out setter))
                {
                    setter.SetValue(objectT, theValue);
                }
                //else, if no setter, do nothing?
            }

            return objectT;
        }
    }
}
