//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Keysight.KtEL30000.Bridge {
[System.CodeDom.Compiler.GeneratedCode("swig","3.0")]

internal class WarningKtEventHandlerAdapter : WarningKtEventHandler {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  private bool swigCMemOwnDerived;

  internal WarningKtEventHandlerAdapter(global::System.IntPtr cPtr, bool cMemoryOwn) : base(KtEL30000CppApiPINVOKE.WarningKtEventHandlerAdapter_SWIGSmartPtrUpcast(cPtr), true) {
    swigCMemOwnDerived = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(WarningKtEventHandlerAdapter obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~WarningKtEventHandlerAdapter() {
    Dispose();
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwnDerived) {
          swigCMemOwnDerived = false;
          KtEL30000CppApiPINVOKE.delete_WarningKtEventHandlerAdapter(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

    
        public WarningKtEventHandlerAdapter(WarningKtEvent evt)
        {
            mEvent = evt;
        }

        public void Add(System.EventHandler<Ivi.Driver.WarningEventArgs> handler)
        {
            if (mClientHandlers == null)
            {
                //inform C++ the subscription
                mEvent += this;
            }
            mClientHandlers += handler;
        }
        public void Remove(System.EventHandler<Ivi.Driver.WarningEventArgs> handler)
        {
            mClientHandlers -= handler;
            if (mClientHandlers == null || mClientHandlers.GetInvocationList().Length == 0)
            {
                //remove C++ subscription
                mEvent -= this;
                mClientHandlers = null;
            }
        }
    
        public override void OnEvent(IviWarningEventArgs args)
        {
            if (mClientHandlers == null)
                throw new System.Exception("No event to trigger");
        
            // Reflection is heavily used here as the event_ is a Object type and doesn't have static types
            // We suppose event_ should be of type EventHandler<T>, note that EventHandler is not supported
            System.Type t = mClientHandlers.GetType();
        
            if (t.IsGenericType && t.GetGenericArguments().Length == 1)
            {
                System.Type targetArgType = t.GetGenericArguments()[0];
                var value = mEventArgHelper.ConvertEquivalent(targetArgType, args);

                System.Reflection.MethodInfo invoke = t.GetMethod("Invoke");
                if(mClientHandlers != null)
                    invoke.Invoke(mClientHandlers, new System.Object[]{ this, value });
            }
        }
    
        public override bool IsOwn() 
        {
            return false;
        }    
    
        private WarningKtEvent mEvent;
        private System.EventHandler<Ivi.Driver.WarningEventArgs> mClientHandlers;
        private Keysight.ApiCoreLibraries.ProxyDataConverter mEventArgHelper = new Keysight.ApiCoreLibraries.ProxyDataConverter();
    
}

}
