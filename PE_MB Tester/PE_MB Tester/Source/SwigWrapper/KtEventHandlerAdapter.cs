//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Keysight.KtEL30000.Bridge {
[System.CodeDom.Compiler.GeneratedCode("swig","3.0")]

internal class KtEventHandlerAdapter : KtEventHandler {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  private bool swigCMemOwnDerived;

  internal KtEventHandlerAdapter(global::System.IntPtr cPtr, bool cMemoryOwn) : base(KtEL30000CppApiPINVOKE.KtEventHandlerAdapter_SWIGSmartPtrUpcast(cPtr), true) {
    swigCMemOwnDerived = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(KtEventHandlerAdapter obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~KtEventHandlerAdapter() {
    Dispose();
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwnDerived) {
          swigCMemOwnDerived = false;
          KtEL30000CppApiPINVOKE.delete_KtEventHandlerAdapter(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

    
    public KtEventHandlerAdapter(KtEvent evt)
    {
        mEvent = evt;
    }

    public void Add(System.EventHandler handler)
    {
        if (mHandler == null)
        {   
            mEvent += this;
        }
        mHandler += handler;
    }
    public void Remove(System.EventHandler handler)
    {
        mHandler -= handler;
        if (mHandler == null || mHandler.GetInvocationList().Length == 0)
        {   
            mEvent -= this;
            mHandler = null;
        }
    }
    
    public override void OnEvent()
    {
        if (mHandler == null)
            throw new System.Exception("No event to trigger");
        
        System.Type t = mHandler.GetType();
        System.Reflection.MethodInfo invoke = t.GetMethod("Invoke");
        if(mHandler != null)
            invoke.Invoke(mHandler, new System.Object[] { this, System.EventArgs.Empty});
    }   
    
    public override bool IsOwn() {return false;}
    
    private KtEvent mEvent;
    private System.EventHandler mHandler;

}

}
